#!/usr/bin/env python3
"""Hide My Email CLI - Generate iCloud Hide My Email addresses."""

import argparse
import json
import os
import stat
import subprocess
import sys
import tempfile
import uuid
from urllib.error import HTTPError, URLError
from urllib.parse import urlencode
from urllib.request import Request, urlopen

CONFIG_DIR = os.path.expanduser("~/.config/hide-my-email")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.json")

DEFAULT_CLIENT_BUILD_NUMBER = "2542Build17"
DEFAULT_CLIENT_MASTERING_NUMBER = "2542Build17"
SETUP_URL = "https://setup.icloud.com/setup/ws/1/validate"
REQUEST_TIMEOUT_SEC = 30


# -- Exceptions ---------------------------------------------------------------


class HmeError(Exception):
    """Base exception for all HME errors."""


class AuthError(HmeError):
    """Cookie expired or invalid."""


class ApiError(HmeError):
    """iCloud API returned an unexpected response."""


class ConfigError(HmeError):
    """Configuration missing or corrupt."""


class NetworkError(HmeError):
    """Network connectivity issue."""


# -- Config I/O ---------------------------------------------------------------


def load_config():
    """Load config.json. Returns None if file does not exist."""
    try:
        with open(CONFIG_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return None
    except (json.JSONDecodeError, OSError) as e:
        raise ConfigError(f"Failed to read {CONFIG_FILE}: {e}")


def save_config(config):
    """Atomically write config.json with owner-only permissions (0600)."""
    os.makedirs(CONFIG_DIR, mode=0o700, exist_ok=True)
    fd, tmp_path = tempfile.mkstemp(dir=CONFIG_DIR, suffix=".tmp")
    try:
        with os.fdopen(fd, "w") as f:
            json.dump(config, f, indent=2)
        os.chmod(tmp_path, stat.S_IRUSR | stat.S_IWUSR)
        os.replace(tmp_path, CONFIG_FILE)
    except BaseException:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass
        raise


# -- HTTP / iCloud API ---------------------------------------------------------


def _build_headers(config):
    return {
        "Origin": "https://www.icloud.com",
        "Referer": "https://www.icloud.com/",
        "Accept": "application/json",
        "Content-Type": "application/json",
        "Cookie": config["cookies"],
        "User-Agent": (
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
            "AppleWebKit/605.1.15 (KHTML, like Gecko) "
            "Version/17.0 Safari/605.1.15"
        ),
    }


def _build_query_params(config):
    return {
        "clientBuildNumber": config.get(
            "client_build_number", DEFAULT_CLIENT_BUILD_NUMBER
        ),
        "clientMasteringNumber": config.get(
            "client_mastering_number", DEFAULT_CLIENT_MASTERING_NUMBER
        ),
        "clientId": config.get("client_id", str(uuid.uuid4()).upper()),
        "dsid": config["dsid"],
    }


def _extract_email(value):
    """Extract an email string from an API response field.

    The HME API may return the address as a plain string or as a dict
    like {"hme": "addr@...", ...}.  This normalises both to a string.
    """
    if isinstance(value, str):
        return value
    if isinstance(value, dict):
        return value.get("hme") or value.get("address") or value.get("email")
    return None


def _parse_cookies(cookie_string):
    """Parse a Cookie header string into an ordered dict."""
    cookies = {}
    for pair in cookie_string.split(";"):
        pair = pair.strip()
        if "=" in pair:
            name, value = pair.split("=", 1)
            cookies[name.strip()] = value.strip()
    return cookies


def _serialize_cookies(cookies_dict):
    """Serialize a cookies dict back into a Cookie header string."""
    return "; ".join(f"{k}={v}" for k, v in cookies_dict.items())


def _merge_set_cookies(config, response_headers):
    """Merge Set-Cookie headers from an API response into stored cookies."""
    set_cookies = response_headers.get_all("Set-Cookie")
    if not set_cookies:
        return

    existing = _parse_cookies(config.get("cookies", ""))

    for sc in set_cookies:
        # Set-Cookie: NAME=VALUE; path=/; domain=...; ...
        cookie_part = sc.split(";", 1)[0]
        if "=" in cookie_part:
            name, value = cookie_part.split("=", 1)
            existing[name.strip()] = value.strip()

    config["cookies"] = _serialize_cookies(existing)
    save_config(config)


def _apply_trust_tokens(config, response_body):
    """Extract trust tokens from a 421 response body and set as HSA-TRUST cookie."""
    try:
        data = json.loads(response_body) if response_body else {}
    except json.JSONDecodeError:
        return
    trust_tokens = data.get("trustTokens", [])
    if not trust_tokens:
        return
    existing = _parse_cookies(config.get("cookies", ""))
    existing["X-APPLE-WEBAUTH-HSA-TRUST"] = trust_tokens[0]
    config["cookies"] = _serialize_cookies(existing)
    save_config(config)


def http_request(method, url, config, data=None, _retried=False):
    """Single HTTP entry-point. Raises HmeError subtypes on failure.

    On HTTP 421 (session token rotation), merges Set-Cookie headers and
    trust tokens from the error response and retries once.
    """
    headers = _build_headers(config)
    body = json.dumps(data).encode("utf-8") if data is not None else None
    req = Request(url, data=body, headers=headers, method=method)
    try:
        with urlopen(req, timeout=REQUEST_TIMEOUT_SEC) as resp:
            _merge_set_cookies(config, resp.headers)
            raw = resp.read().decode("utf-8")
            return json.loads(raw) if raw else {}
    except HTTPError as e:
        if e.code == 421 and not _retried:
            # Apple rotates session tokens via 421 + Set-Cookie + trustTokens.
            # Merge cookies and trust tokens, then retry once.
            _merge_set_cookies(config, e.headers)
            error_body = e.read().decode("utf-8", errors="replace")
            _apply_trust_tokens(config, error_body)
            return http_request(method, url, config, data=data, _retried=True)
        if e.code in (401, 421):
            raise AuthError(
                "Cookie expired or invalid. Run 'hme setup' to re-configure."
            )
        error_body = e.read().decode("utf-8", errors="replace")
        raise ApiError(f"HTTP {e.code}: {error_body}")
    except json.JSONDecodeError as e:
        raise ApiError(f"Invalid JSON in API response: {e}")
    except URLError as e:
        raise NetworkError(f"Network error: {e.reason}")


def validate_and_cache(config):
    """Call /validate to obtain DSID and base URL, then persist them."""
    # Preserve the original browser cookies.  /validate may rotate them
    # (via Set-Cookie on 421 retry), but the rotated values are only needed
    # for the /validate retry itself — they break subsequent HME API calls.
    original_cookies = config["cookies"]
    try:
        result = http_request("POST", SETUP_URL, config)
    finally:
        config["cookies"] = original_cookies
        save_config(config)

    dsid = result.get("dsInfo", {}).get("dsid")
    if not dsid:
        raise ApiError("Could not retrieve DSID from validate response.")

    base_url = (
        result.get("webservices", {}).get("premiummailsettings", {}).get("url")
    )
    if not base_url:
        raise ApiError(
            "Could not retrieve premiummailsettings URL. "
            "Ensure your iCloud account has Hide My Email enabled."
        )

    config["dsid"] = str(dsid)
    config["base_url"] = base_url
    config["client_id"] = str(uuid.uuid4()).upper()
    save_config(config)
    return config


def ensure_config():
    """Return a validated config, running /validate if needed."""
    config = load_config()
    if not config or not config.get("cookies"):
        raise ConfigError("Not configured. Run 'hme setup' first.")
    if not config.get("dsid") or not config.get("base_url"):
        print("Validating session...", file=sys.stderr)
        config = validate_and_cache(config)
    return config


# -- Clipboard ----------------------------------------------------------------


def copy_to_clipboard(text):
    subprocess.run(["pbcopy"], input=text.encode("utf-8"), check=True)


def read_clipboard():
    """Read text from macOS clipboard via pbpaste."""
    result = subprocess.run(
        ["pbpaste"], capture_output=True, timeout=5,
    )
    return result.stdout.decode("utf-8", errors="replace").strip()


# -- Sub-commands --------------------------------------------------------------


def _save_cookie_and_validate(cookie_input):
    """Validate a cookie string, save to config, and run /validate."""
    if cookie_input.lower().startswith("cookie:"):
        cookie_input = cookie_input[len("cookie:"):].strip()

    if not cookie_input or "X-APPLE" not in cookie_input.upper():
        raise ConfigError(
            "Clipboard does not contain iCloud cookies. "
            "Copy the 'Cookie' request header value from icloud.com first."
        )

    config = load_config() or {}
    config["cookies"] = cookie_input
    config.pop("dsid", None)
    config.pop("base_url", None)
    config.pop("client_id", None)
    save_config(config)

    config = validate_and_cache(config)
    return config


def prompt_cookie(open_browser=True):
    """Prompt user for a cookie, validate, and save. Returns refreshed config."""
    if open_browser:
        print("Opening icloud.com ...", file=sys.stderr)
        subprocess.run(["open", "https://www.icloud.com"], check=False)
        print(file=sys.stderr)
    print("1. Log in to icloud.com (if not already)", file=sys.stderr)
    print("2. Open DevTools: Cmd+Option+I -> Network tab", file=sys.stderr)
    print("3. Reload: Cmd+R", file=sys.stderr)
    print("4. Click any request -> Headers -> Request Headers", file=sys.stderr)
    print("5. Right-click the 'Cookie' row -> Copy value", file=sys.stderr)
    print("6. Come back here and press Enter", file=sys.stderr)
    print(file=sys.stderr)

    input("Press Enter after copying the Cookie...")

    print("Validating session...", file=sys.stderr)
    config = _save_cookie_and_validate(read_clipboard())
    print(f"Session refreshed (DSID: {config['dsid']})", file=sys.stderr)
    return config


def setup_from_clipboard():
    """Read cookie from clipboard (non-interactive), validate, and save."""
    return _save_cookie_and_validate(read_clipboard())


def cmd_setup(_args):
    """Interactive Cookie setup."""
    print("=== Hide My Email Setup ===", file=sys.stderr)
    print(file=sys.stderr)
    prompt_cookie(open_browser=True)
    print(f"Config saved to {CONFIG_FILE}", file=sys.stderr)


def cmd_generate(args):
    """Generate a new Hide My Email address."""
    config = ensure_config()
    params = urlencode(_build_query_params(config))
    base_url = config["base_url"]

    # Step 1: Generate a random address
    gen_result = http_request(
        "POST", f"{base_url}/v1/hme/generate?{params}", config
    )
    hme_raw = gen_result.get("result", {}).get("hme")
    hme_address = _extract_email(hme_raw)
    if not hme_address:
        raise ApiError(f"Failed to generate address: {json.dumps(gen_result)}")

    # Step 2: Reserve with label/note (best-effort — still output address on failure)
    reserve_data = {
        "hme": hme_address,
        "label": args.label or "",
        "note": args.note or "",
    }
    try:
        reserve_result = http_request(
            "POST",
            f"{base_url}/v1/hme/reserve?{params}",
            config,
            data=reserve_data,
        )
        reserved_raw = reserve_result.get("result", {}).get("hme")
        final_address = _extract_email(reserved_raw) or hme_address
    except HmeError as e:
        print(
            f"Warning: Generated {hme_address} but reserve failed: {e}",
            file=sys.stderr,
        )
        final_address = hme_address

    if args.clipboard:
        try:
            copy_to_clipboard(final_address)
        except (OSError, subprocess.CalledProcessError) as e:
            print(f"Warning: Clipboard copy failed: {e}", file=sys.stderr)

    print(final_address)


def _fetch_addresses(config):
    """Fetch all HME addresses from the API."""
    params = urlencode(_build_query_params(config))
    base_url = config["base_url"]
    result = http_request("GET", f"{base_url}/v2/hme/list?{params}", config)
    return result.get("result", {}).get("hmeEmails", [])


def _format_address(addr):
    """Format a single HME address for display."""
    email = addr.get("hme", "")
    label = addr.get("label", "")
    forward = addr.get("forwardToEmail", "")
    is_active = addr.get("isActive", True)
    status = "" if is_active else " [inactive]"
    label_str = f"  ({label})" if label else ""
    forward_str = f"  -> {forward}" if forward else ""
    return f"{email}{label_str}{forward_str}{status}"


def cmd_list(_args):
    """List existing Hide My Email addresses."""
    config = ensure_config()
    addresses = _fetch_addresses(config)
    if not addresses:
        print("No Hide My Email addresses found.", file=sys.stderr)
        return

    for addr in addresses:
        print(_format_address(addr))


def cmd_search(args):
    """Search HME addresses by label or note."""
    config = ensure_config()
    addresses = _fetch_addresses(config)
    query = args.query.lower()

    matches = [
        addr for addr in addresses
        if query in addr.get("label", "").lower()
        or query in addr.get("note", "").lower()
    ]

    if not matches:
        print(f"No addresses matching '{args.query}'.", file=sys.stderr)
        sys.exit(6)

    if args.clipboard:
        email = matches[0].get("hme", "")
        try:
            copy_to_clipboard(email)
            if len(matches) > 1:
                print(
                    f"Copied first match to clipboard: {email}",
                    file=sys.stderr,
                )
        except (OSError, subprocess.CalledProcessError) as e:
            print(f"Warning: Clipboard copy failed: {e}", file=sys.stderr)

    for addr in matches:
        print(_format_address(addr))


def cmd_setup_clipboard(_args):
    """Non-interactive setup: read cookie from clipboard and validate."""
    config = setup_from_clipboard()
    print(f"Session refreshed (DSID: {config['dsid']})", file=sys.stderr)


def cmd_refresh(_args):
    """Re-configure cookies (alias for setup)."""
    cmd_setup(_args)


# -- Entry point ---------------------------------------------------------------


def main():
    parser = argparse.ArgumentParser(
        description="Hide My Email CLI - Generate iCloud Hide My Email addresses"
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    subparsers.add_parser("setup", help="Initial Cookie setup (interactive)")

    gen_parser = subparsers.add_parser("generate", help="Generate a new HME address")
    gen_parser.add_argument("--label", "-l", default="", help="Label (site name)")
    gen_parser.add_argument("--note", "-n", default="", help="Note/memo")
    gen_parser.add_argument(
        "--clipboard",
        "-c",
        action="store_true",
        default=True,
        help="Copy to clipboard (default: true)",
    )
    gen_parser.add_argument(
        "--no-clipboard",
        action="store_false",
        dest="clipboard",
        help="Do not copy to clipboard",
    )

    subparsers.add_parser("list", help="List existing HME addresses")

    search_parser = subparsers.add_parser("search", help="Search by label or note")
    search_parser.add_argument("query", help="Search query")
    search_parser.add_argument(
        "--clipboard",
        "-c",
        action="store_true",
        default=True,
        help="Copy first match to clipboard (default: true)",
    )
    search_parser.add_argument(
        "--no-clipboard",
        action="store_false",
        dest="clipboard",
        help="Do not copy to clipboard",
    )

    subparsers.add_parser(
        "setup-clipboard",
        help="Setup from clipboard (non-interactive, for Raycast)",
    )
    subparsers.add_parser("refresh", help="Re-configure cookies")

    args = parser.parse_args()
    if args.command is None:
        parser.print_help()
        sys.exit(1)

    commands = {
        "setup": cmd_setup,
        "setup-clipboard": cmd_setup_clipboard,
        "generate": cmd_generate,
        "list": cmd_list,
        "search": cmd_search,
        "refresh": cmd_refresh,
    }
    try:
        try:
            commands[args.command](args)
        except (AuthError, ConfigError) as e:
            if args.command in ("setup", "setup-clipboard") or not sys.stdin.isatty():
                raise
            print(f"{e}", file=sys.stderr)
            print(file=sys.stderr)
            prompt_cookie(open_browser=True)
            commands[args.command](args)
    except AuthError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(2)
    except ConfigError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(3)
    except ApiError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(4)
    except NetworkError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(5)
    except KeyboardInterrupt:
        sys.exit(130)


if __name__ == "__main__":
    main()
